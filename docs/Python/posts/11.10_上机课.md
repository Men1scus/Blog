

## Non-Overlapping Substrings

You are given string *s*. Your task is to determine if the given string *s* contains two non-overlapping substrings "AB" and "BA" (the substrings can go in any order).

**Input**

The only line of input contains a string *s* of length between 1 and 105 consisting of uppercase Latin letters.

**Output**

Print "YES" (without the quotes), if string *s* contains two non-overlapping substrings "AB" and "BA", and "NO" otherwise.

**Examples**

**input**

ABA

**output**

NO

**input**

BACFAB

**output**

YES

**input**

AXBYBXA

**output**

NO

**Note**

In the first sample test, despite the fact that there are substrings "AB" and "BA", their occurrences overlap, so the answer is "NO".

In the second sample test there are the following occurrences of the substrings: **BA**CF**AB**.

In the third sample test there is no substring "AB" nor substring "BA".

 

```python
#1
s = input()
if "AB" no in s or "BA" not in s:
    print("NO")
else:
    a = s.find("AB")
    b = s.find("BA")
    c = s.rfind("AB")
    d = s.rfind("BA")
    if a+1<d of b+1<c:
        print("YES")
    else 
    	print("NO")
```

```python
#2
s = input()
if "BA" in s and s.find("AB",s.find("BA")+2) > 0:
    print("YES")
elif "AB" in s and s.find("BA",s.find("AB")+2) > 0:
    print("YES")
else:
    print("NO")
```

```python
#3
s=input()
a = s.find("AB")
b = s.find("BA",a+2)
c = s.rfind("AB")
d = s.rfind("BA",c+2)
print("YES" if (a != -1 and b != -1) or (c != -1 and d != -1) else "NO")
```

```python
#4
s = input()
a = s.find("AB")
b=s[a+2:].find("BA") #字符串也是一种list，就可以用切片解决
c = s.rfind("AB")
d = s[c+2:].rfind("BA")
```

```python
#my
s = input()
if s.count("AB") > 0 and s.replace("AB", "$", 1).count("BA") > 0:
    pass
elif s.count("BA") > 0 and s.replace("BA", "$", 1).count("AB") > 0:
    pass
else:
    pass
```



## Magnetic Dominoes

Mad scientist Mike entertains himself by arranging rows of dominoes. He only has  rectangular magnetic dominoes now. Each magnet has two poles, positive (a "plus") and negative (a "minus"). If two magnets are put together at a close distance, then the like poles will repel each other and the opposite poles will attract each other.

Mike starts by laying one magnet horizontally on the table. During each following step Mike adds one more magnet horizontally to the right end of the row. Depending on how Mike puts the magnet on the table, it is either attracted to the previous one (forming a group of multiple magnets linked together) or repelled by it (then Mike lays this magnet at some distance to the right from the previous one). We assume that a sole magnet not linked to others forms a group of its own.

![http://codeforces.com/predownloaded/24/1f/241face1b1e11cfb8bf591b3e609248bf6d85d78.png](https://cdn.jsdelivr.net/gh/Meniscus0/FigureBed@main/img/202311101112229.png)

Mike arranged multiple magnets in a row. Determine the number of groups that the magnets formed.

**Input**

The first line of the input contains an integer *n* (1 ≤ *n* ≤ 100000) — the number of magnets. Then *n* lines follow. The *i*-th line (1 ≤ *i* ≤ *n*) contains either characters "01", if Mike put the *i*-th magnet in the "plus-minus" position, or characters "10", if Mike put the magnet in the "minus-plus" position.

**Output**

On the single line of the output print the number of groups of magnets.

**Examples**

**input**

```
6
 10
 10
 10
 01
 10
 10
```

**output**

```
3
```

**input**

```
4
 01
 01
 10
 10
```

**output**

```
2
```

**Note**

The first testcase corresponds to the figure. The testcase has three groups consisting of three, one and two magnets.

The second testcase has two groups, each consisting of two magnets.



找到不一样的点之后+1

 

```python
n=''
for i in range(int(input())):
    n+=input()
print(n.count('00')+n.count('11')+1)
```

```python

```

```python

```

