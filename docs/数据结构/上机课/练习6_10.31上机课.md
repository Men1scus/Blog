作业6

1. 所谓双端队列（double-ended queue，deque），就是在列表的两端都可以插入和删除数据。因此它允许的操作有Create、IsEmpty、IsFull、Left、Right、AddLeft、AddRight、DeleteLeft、DeleteRight。使用循环数组方式实现双端队列，要求实现上述操作，并实现一个Print输出操作，能将队列由左至右的次序输出于一行，元素间用空格间隔。队列元素类型设为整型。

输入：input.txt，给出一个操作序列，可能是Create、Print之外的任何操作，需要的情况下，会给出参数。最后以关键字“End”结束，例如：

AddLeft	1
AddLeft	2
DeleteRight
IsFull
DeleteLeft
IsEmpty
AddRight 3
AddLeft 2
AddRight 1
End

输出：程序开始执行时，队列设置为空，按输入顺序执行操作，每个操作执行完后，将结果输出于一行。对于错误命令，输出“WRONG”。对IsEmpty和IsFull命令，试情况输出“Yes”或“No”。对Left和Right命令，若队列空，输出“EMPTY”，否则输出对应队列元素。对Add命令，若队列满，输出“FULL”，否则调用Print，输出队列所有元素。对Del命令，若队列空，输出“EMPTY”，否则输出所有元素。元素间用空格间隔，最后一个元素后不能有空格。最后输出一个回车。

例如，对上例，应输出：
―――――――――
1
2 1
2
No

Yes
3
2 3
2 3 1

――――――――――――――――



> ```c++
> #include<fstream>
> #include<string>
> #include<sstream>
> 
> ifstream input("input6.1.txt");
> //ifstream输入文件流（input file stream 输入到input对象中
> input.getline(s0,sizeof(s0));
> //从input中逐行读取字符串到s0中
>istringstream iss(s0);
> char s[20];
> //将每一行的第一组元素先输入到字符数组s中
> iss >> s;
> int x;
> ```
> 
><sstream> 头文件
> istringstream类：从 string 对象中读取 读取由空格隔开的数据，可以完成字符串到其他类型的转换。

```C++
#include<iostream>
#include<fstream>
#include<string>
#include<sstream>
using namespace std;

class Deque {
private:
	int* p;
	int len;
	int cnt;
public:
	Deque(int x) {
		len = x;
		p = new int[len];
		memset(p, 0, sizeof(int)*len);
		cnt = 0;
	};
	bool IsEmpty();
	bool IsFull();
	int Left();
	int Right();
	void AddLeft(int x);
	void AddRight(int x);
	void DeleteLeft();
	void DeleteRight();
	void Print();
};
void Deque::Print() {
	for (int i = 0; i < cnt; i++)
		cout << p[i] << ' ';
	cout << endl;
}
bool Deque::IsEmpty() {
	if (cnt == 0)
		return 1;
	return 0;
}
bool Deque::IsFull() {
	if (cnt == len)
		return 1;
	return 0;
}
int Deque::Left() {
	return p[0];
}
int Deque::Right() {
	return p[max(0,cnt-1)];
}
void Deque::AddLeft(int x) {
	for (int i = cnt - 1; i >= 0;i--)
		p[i + 1] = p[i];
	p[0] = x;
	cnt++;
}
void Deque::AddRight(int x) {
	p[cnt] = x;
	cnt++;
}
void Deque::DeleteLeft() {
	for (int i = 0; i < cnt - 1; i++)
		p[i] = p[i + 1];
	cnt--;
}
void Deque::DeleteRight() {
	p[cnt - 1] = 0;
	cnt--;
}
int main() {
	Deque d(15);
	char s0[20];
	char s1[20]="Create";
	char s2[20] = "IsEmpty";
	char s3[20] = "IsFull";
	char s4[20] = "Left";
	char s5[20] = "Right";
	char s6[20] = "AddLeft";
	char s7[20] = "AddRight";
	char s8[20] = "DeleteLeft";
	char s9[20] = "DeleteRight";
	char s10[20] = "End";
	ifstream input("input6.1.txt");
	while (input.getline(s0,sizeof(s0))){
		istringstream iss(s0);
		char s[20];
		iss >> s;
		int x;
		if (!strcmp(s, s1)) {
			Deque d(15);
		}
		else if (!strcmp(s, s2)) {
			if (d.IsEmpty()) {
				cout << "Yes" << endl;
			}
			else
				cout << "NO" << endl;
		}
		else if (!strcmp(s, s3)) {
			if (d.IsFull()) {
				cout << "Yes" << endl;
			}
			else
				cout << "NO" << endl;
		}
		else if (!strcmp(s, s4)) {
			if (d.IsEmpty())
				cout << "EMPTY" << endl;
			else
				cout << d.Left() << endl;
		}
		else if (!strcmp(s, s5)) {
			if (d.IsEmpty())
				cout << "EMPTY" << endl;
			else
				cout << d.Right() << endl;
		}
		else if (!strcmp(s, s6)) {
			iss >> x;
			if (d.IsFull())
				cout << "FULL" << endl;
			else {
				d.AddLeft(x);
				d.Print();
			}
		}
		else if (!strcmp(s, s7)) {
			iss >> x;
			if (d.IsFull())
				cout << "FULL" << endl;
			else {
				d.AddRight(x);
				d.Print();
			}
		}
		else if (!strcmp(s, s8)) {
			if (d.IsEmpty())
				cout << "EMPTY" << endl;
			else {
				d.DeleteLeft();
				d.Print();
			}
		}
		else if (!strcmp(s, s9)) {
			if (d.IsEmpty())
				cout << "EMPTY" << endl;
			else {
				d.DeleteRight();
				d.Print();
			}
		}
		else if (!strcmp(s, s10)) {
			break;
		}
		else
			cout << "WRONG" << endl;
	}
	input.close();
	return 0;
}
```




2.	输入一个中缀表达式，构造表达式树，以文本方式输出树结构。
输入：例如，输入a+b+c*(d+e)



输出：以缩进表示二叉树的层次，左——根、右——叶、上——右子树、下——左子树
―――――――――――――――――――
			e
		+
			d
	*
		c
+
		b
	+
		a

――――――――――――――――――――――
提示：以什么样的顺序对树进行遍历可以容易地输出为这种形式？标准顺序显然是不行的。不同层次对应不同缩进如何实现？可以为递归函数设定一个参数表示层次（缩进量），递归调用时加以改变即可。另外，如何将input.txt转换为二叉树结构，除了链接实现的二叉树结构外，可能还需要一些辅助结构。



3.	编写二叉树类的成员函数，分别实现以下功能：
①	统计二叉树的叶节点的数目
②	交换二叉树中所有节点的左右子树
③	按层次顺序遍历二叉树：首先访问根节点，然后是它的两个孩子节点，然后是孙子节点，依此类推
④	求二叉树的宽度，即同一层次上最多的节点数

要求以任意可行的方式输入一棵二叉树，程序依次显示上述各项处理的结果。